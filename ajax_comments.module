<?php

/**
 * Implementation of hook_init().
 * See README.txt for why this is necessary.
 */
function ajax_comments_init() {
  if (isset($_POST['ajax_html_ids']) && count($_POST['ajax_html_ids']) == 1) {
    $_POST['ajax_html_ids'] = explode(',', $_POST['ajax_html_ids'][0]);
  }
}
/**
 * Implementation of hook_menu().
 */
function ajax_comments_menu() {  
  $items['ajax_comments/reply/%/%'] = array(
    'page callback' => 'ajax_comments_reply',
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'page arguments' => array(2, 3),
    'type' => MENU_CALLBACK,
  );
  
  $items['ajax_comments/edit/%'] = array(
    'page callback' => 'ajax_comments_edit',
    'access callback' => 'user_access',
    'access arguments' => array('edit own comments'),
    'page arguments' => array(2),
    'type' => MENU_CALLBACK,
  );
  
  $items['ajax_comments/delete/%'] = array(
    'page callback' => 'ajax_comments_delete',
    'access callback' => 'user_access',
    'access arguments' => array('administer comments'),
    'page arguments' => array(2),
    'type' => MENU_CALLBACK,
  );
  
  $items['admin/config/content/ajax_comments'] = array(
    'title' => 'AJAX comments',
    'description' => 'AJAXifies comments on site.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ajax_comments_settings'),
    'access arguments' => array('administer site configuration'),
    'file' => 'ajax_comments.admin.inc',
   );
  return $items;
}

/**
 * Implementation of hook_form_alter().
 */
function ajax_comments_form_comment_form_alter(&$form, &$form_state, $form_id) {
  // Check to see if this node type uses ajax comments.
  if (!ajax_comments_node_type_active($form['#node']->type)) {
    return;
  }
      
  $form['actions']['submit']['#ajax'] = array(
    'callback' => 'ajax_comments_submit_js',
    'wrapper' => $form['#id'],
    'method' => 'replace',
    'effect' => 'fade',
  );
    
  // HACK, stop ctools from modifying us in node_comment_form.inc
  $form_state['ctools comment alter'] = FALSE;
}

/**
 * Implementation of hook_form_alter().
 */
function ajax_comments_form_comment_confirm_delete_alter(&$form, &$form_state, $form_id) {
  $comment = $form['#comment'];  
  $node = node_load($comment->nid);
  
  // Check to see if this node type uses ajax comments.
  if (!ajax_comments_node_type_active($node->type)) {
    return;
  }
  
  $form['actions']['submit']['#ajax'] = array(
    'callback' => 'ajax_comments_delete_js',
    'wrapper' => $form['#id'],
    'method' => 'replace',
    'effect' => 'fade',
  );
  
  $form['actions']['cancel']['#attributes']['onclick'][] = 'jQuery(\'#' . $form['#id'] . '\').siblings().show().end().remove(); return false;';
}

/**
 * Builds the comment.
 */
function ajax_comments_submit_js($form, &$form_state) {
  // return the actual form if it contains errors
  if (form_get_errors()) {
    return $form;
  }
    
  // This is to remove the "Your comment has been posted" status message that 
  // will appear upon refresh. This seems dirty but it means we don't have to
  // rewrite the whole comment_form_submit(). Please chime in if you think this is dumb.
  ajax_comments_remove_status($_SESSION);
    
  $comment = $form_state['comment'];
  $node = $form['#node'];

  $comment_build = comment_view($comment, $node);

  // Are we editing a comment  
  if (isset($form['cid']['#value'])) {
    // remove wrapper because the form we replace exists inside the wrapper
    unset($comment_build['#prefix']);
    unset($comment_build['#suffix']);
    
    // trim surrounding whitespace so ajax.js doesn't wrap us in a new div
    $comment_output = trim(drupal_render($comment_build));    
    $commands[] = ajax_command_replace('#' . $form['#id'], $comment_output);
  }
  // Or are we replying to another comment
  else if (isset($form_state['values']['pid'])) {
    // append comment to parent wrapper
    $comment_output = drupal_render($comment_build);
    $commands[] = ajax_command_append('#comment-wrapper-' . $comment->pid, $comment_output);
    
    // delete the form
    $commands[] = ajax_command_invoke('#' . $form['#id'], 'remove');
  }
  // Or is this a brand new comment
  else {
    // append comment to root comment wrapper
    $comment_output = drupal_render($comment_build);
    $commands[] = ajax_command_append('#comment-wrapper', $comment_output);
    
    // we were using the main comment form, replace it with a new one
    $node = $form['#node'];
    
    $new_form_state = array();
    $new_form_state['build_info']['args'][] = (object) array('nid' => $node->nid);
    $new_form_state['input'] = array(); // don't pull from cache        
    $new_form_build = drupal_build_form($form['#form_id'], $new_form_state);    
    $new_form_output = drupal_render($new_form_build);
    
    $commands[] = ajax_command_replace('#' . $form['#id'], $new_form_output);
  }  
  
  return array('#type' => 'ajax', '#commands' => $commands);
}

/**
 * Remove the comment.
 */
function ajax_comments_delete_js($form, &$form_state) {  
  $comment = $form['#comment'];
    
  $commands[] = ajax_command_remove('#comment-wrapper-' . $comment->cid);
  
  return array('#type' => 'ajax', '#commands' => $commands);
}

/**
 * Implementation of hook_comment_view().
 */
function ajax_comments_comment_view($comment, $view_mode, $langcode) {
  $active = ajax_comments_node_type_active(ltrim($comment->node_type, 'comment_node_'));
  
  if (!$active) {
    return;
  }
  
  // Reply
  if (isset($comment->content['links']['comment']['#links']['comment-reply'])) {
    $comment->content['links']['comment']['#links']['comment-reply']['attributes']['class'] = array('use-ajax');
    $comment->content['links']['comment']['#links']['comment-reply']['href'] = 'ajax_comments/reply/' . $comment->nid . '/' . $comment->cid;
  }
  
  // Edit
  if (isset($comment->content['links']['comment']['#links']['comment-edit'])) {
    $comment->content['links']['comment']['#links']['comment-edit']['attributes']['class'] = array('use-ajax');
    $comment->content['links']['comment']['#links']['comment-edit']['href'] = 'ajax_comments/edit/' . $comment->cid;
  }

  // Delete
  if (isset($comment->content['links']['comment']['#links']['comment-delete'])) {
    $comment->content['links']['comment']['#links']['comment-delete']['attributes']['class'] = array('use-ajax');
    $comment->content['links']['comment']['#links']['comment-delete']['href'] = 'ajax_comments/delete/' . $comment->cid;
  }
}

/**
 * Implementation of hook_node_view_alter().
 * Wrap all comments in #comment-wrapper
 */
function ajax_comments_node_view_alter(&$build) {
  $build['comments']['comments']['#prefix'] = '<div id="comment-wrapper">';
  $build['comments']['comments']['#suffix'] = '</div>';
}

/**
 * Implementation of hook_panels_pane_content_alter().
 * Wrap all comments in #comment-wrapper
 */
function ajax_comments_panels_pane_content_alter(&$content, $pane, $args, $context) {  
  if ($pane->type == 'node_comments') {
    $content->content = '<div id="comment-wrapper">' . $content->content . '</div>'; 
  }
}

/**
 * Implementation of hook_comment_view_alter().
 * Wrap comments and their replies in a #comment-wrapper-(cid) div
 */
function ajax_comments_comment_view_alter(&$build, $view_mode) {
  $comment = $build['#comment'];
  $node = $build['#node'];
  
  if (empty($comment->in_preview)) {
    $prefix = '';
      
    // close any previous wrapper elements    
    if ($comment->wrappers_to_close > 0) {
      $prefix .= str_repeat('</div>', $comment->wrappers_to_close);
    }
    
    // add 'new' anchor if needed
    if (!empty($comment->first_new)) {
      $prefix .= "<a id=\"new\"></a>\n";
    }
    
    // add wrapper tag
    $indent = $comment->pid != 0 && variable_get('comment_default_mode_' . $node->type, COMMENT_MODE_THREADED) == COMMENT_MODE_THREADED;
    $prefix .= '<div id="comment-wrapper-' . $comment->cid . '"' . ($indent == TRUE ? ' class="indented"' : '') . '>';

    // add anchor tag
    $prefix .= "<a id=\"comment-$comment->cid\"></a>\n";
    
    $build['#prefix'] = $prefix;
    
    // close last wrapper element
    if(!empty($comment->final_wrappers_to_close)) {
      $build['#suffix'] = str_repeat('</div>', $comment->final_wrappers_to_close);
    }
  }
}

function ajax_comments_entity_prepare_view($entities, $entity_type, $langcode) {
  if ($entity_type == 'comment') {
    $i = 0;
    $opened = 0;
    
    foreach ($entities as $id => $entity) {
      $depth = count(explode('.', $entity->thread)) - 1;
    
      $entity->wrappers_to_close = 0;
              
      if ($depth > $opened) {
        $opened++;
      } else {
        $entity->wrappers_to_close = ($i == 0 ? 0 : 1) + ($opened - $depth);
      
        while ($depth < $opened) {
          $opened--;
        }
      }      
            
      $i++;
    }
    
    $entities[$id]->final_wrappers_to_close = $opened + 1;
  }
}

/**
 *  Callback for clicking "reply".
 */
function ajax_comments_reply($nid, $cid) {
  // Necessary to make available only on certain nodes.
  $node = node_load($nid);
  $edit = array('nid' => $node->nid);
  
  // If there is a cid this is a reply to a comment.
  if ($cid) {
    $edit = $edit + array('pid' => $cid);
  }
  
  if (user_access('post comments') && $node->comment == COMMENT_NODE_OPEN && (variable_get('comment_form_location_' . $node->type, COMMENT_FORM_BELOW) == COMMENT_FORM_BELOW)) {
    $form_build = drupal_get_form("comment_node_{$node->type}_form", (object) $edit);    
    $form = drupal_render($form_build);
  }
  
  // Delete any extra forms we've created
  $commands[] = ajax_command_invoke('[id^=comment-wrapper-] form.comment-form', 'remove');
    
  // Add the new form
  $commands[] = ajax_command_after('#comment-wrapper-' . $cid . ' >.comment', $form);
  
  $page = array('#type' => 'ajax', '#commands' => $commands);
  
  ajax_deliver($page);
}

/**
 *  Callback for clicking "edit".
 */
function ajax_comments_edit($cid) {
  global $base_path;
  global $user;
  
  // Load comment and related node  
  $comment = comment_load($cid);
  $node = node_load($comment->nid);
  if ( ( (user_access('edit own comments') && $comment->uid == $user->uid ) || user_access('administer comments') )
      && $node->comment == COMMENT_NODE_OPEN
      && (variable_get('comment_form_location_' . $node->type, COMMENT_FORM_BELOW) == COMMENT_FORM_BELOW)) {
    $form_build = drupal_get_form("comment_node_{$node->type}_form", $comment);
    $form = drupal_render($form_build);
  }
  
  // Replace comment with form
  $commands[] = ajax_command_replace('#comment-wrapper-' . $cid . ' >.comment', $form);
  
  $page = array('#type' => 'ajax', '#commands' => $commands);
  
  ajax_deliver($page);
}

/**
 *  Callback for clicking "delete".
 */
function ajax_comments_delete($cid) {
  $comment = comment_load($cid);
  
  if (!$comment) {
    return;
  }
  
  // Need to include comment module admin file for delete form
  $form_state = array();
  $form_state['build_info']['args'] = array($comment);
  
  // load this using form_load_include so it's cached properly and works in the ajax callback
  form_load_include($form_state, 'inc', 'comment', 'comment.admin');  
  $form_build = drupal_build_form('comment_confirm_delete', $form_state);  
  $form = drupal_render($form_build);
  
  // Hide contents
  $commands[] = ajax_command_invoke('#comment-wrapper-' . $cid . ' >*', 'hide');
  
  // Put form inside main comment wrapper
  $commands[] = ajax_command_prepend('#comment-wrapper-' . $cid, $form);
  
  $page = array('#type' => 'ajax', '#commands' => $commands);  
  ajax_deliver($page);
}

/**
 * Remove "Your comment has been posted." or "Your comment has been queued.."
 *   from the status message.
 */
function ajax_comments_remove_status(&$_SESSION) {
  $published = t('Your comment has been posted.');
  $not_published = t('Your comment has been queued for review by site administrators and will be published after approval.');
  foreach ($_SESSION['messages']['status'] as $key => $value) {
    if ($value == $published || $value == $not_published) {
      unset($_SESSION['messages']['status']);
    }
  }
} 

/**
 * Return true if this node uses ajax comments.
 */
function ajax_comments_node_type_active($node_type) {
  $types = variable_get('ajax_comments_node_types');
  return isset($types[$node_type]) ? $types[$node_type] : NULL;
}
